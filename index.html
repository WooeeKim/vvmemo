<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Infinite Memo Flow</title>
  <style>
    :root {
      --background: #0b0c10;
      --backgroundGradient: linear-gradient(180deg, #10141d 0%, #0b0c10 45%, #07080c 100%);
      --foreground: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.62);
      --cardShadow: 0 18px 55px rgba(0,0,0,0.45);
      --cardBorder: rgba(255,255,255,0.10);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--background);
      background-image: var(--backgroundGradient);
      color: var(--foreground);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
      overflow: hidden;
      touch-action: manipulation;
      user-select: none;
    }

    #viewport {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    #hud {
      position: absolute;
      top: 14px;
      left: 14px;
      right: 14px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      z-index: 50;
      pointer-events: none;
    }

    #hint {
      pointer-events: none;
      font-size: 13px;
      line-height: 1.35;
      color: var(--muted);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(10px);
      max-width: 70ch;
    }

    #controls {
      display: flex;
      gap: 8px;
      pointer-events: auto;
      align-items: center;
    }

    .controlButton {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--foreground);
      padding: 9px 11px;
      border-radius: 12px;
      font-size: 12px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: transform 120ms ease, background 120ms ease, border 120ms ease;
    }
    .controlButton:hover {
      background: rgba(255,255,255,0.09);
      border-color: rgba(255,255,255,0.18);
      transform: translateY(-1px);
    }
    .controlButton:active {
      transform: translateY(0px);
    }

    #noteLayer {
      position: absolute;
      inset: 0;
      z-index: 10;
    }

    .note {
      position: absolute;
      width: 220px;
      min-height: 130px;
      padding: 14px 14px 12px 14px;
      border-radius: 18px;
      box-shadow: var(--cardShadow);
      border: 1px solid var(--cardBorder);
      overflow: hidden;
      transform-origin: center;
      transform: rotate(var(--note-rotate, 0deg)) scale(1);
      cursor: default;
      user-select: none;
      transition: transform 160ms ease, box-shadow 160ms ease;
    }

    .note.is-hovered {
      transform: rotate(var(--note-rotate, 0deg)) scale(1.06);
      box-shadow: 0 24px 70px rgba(0,0,0,0.55);
    }

    .note::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(120px 90px at 18% 22%, rgba(255,255,255,0.16), transparent 60%),
        radial-gradient(220px 160px at 85% 70%, rgba(0,0,0,0.18), transparent 70%);
      opacity: 0.55;
      pointer-events: none;
      mix-blend-mode: soft-light;
    }

    .noteBody {
      font-size: 14px;
      line-height: 1.35;
      color: rgba(15, 16, 20, 0.92);
      white-space: pre-wrap;
      word-break: break-word;
      min-height: 72px;
      user-select: text;
    }

    .noteTimestamp {
      font-size: 11px;
      color: rgba(15,16,20,0.60);
      opacity: 0.95;
      margin-top: 10px;
    }

    #editorOverlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 18px;
    }

    #editorPanel {
      width: min(640px, 100%);
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      backdrop-filter: blur(14px);
      padding: 14px;
      box-shadow: 0 30px 90px rgba(0,0,0,0.55);
    }

    #editorHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
      color: rgba(255,255,255,0.90);
      font-size: 13px;
    }

    #editorTextarea {
      width: 100%;
      height: 220px;
      resize: vertical;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.25);
      color: rgba(255,255,255,0.92);
      padding: 12px;
      outline: none;
      font-size: 14px;
      line-height: 1.45;
      box-sizing: border-box;
    }

    #editorActions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 10px;
    }

    .editorButton {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      padding: 9px 12px;
      border-radius: 12px;
      font-size: 12px;
      cursor: pointer;
    }
    .editorButton.danger {
      border-color: rgba(255,120,120,0.32);
      background: rgba(255,80,80,0.10);
    }

    @media (max-width: 520px) {
      .note { width: 200px; }
      #hint { max-width: 52ch; }
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="hud">
      <div id="hint">
        화면을 터치/클릭하면 그 위치 색으로 메모가 생성됩니다.<br>
        메모 더블클릭(모바일: 길게 누르기)으로 편집. 흐름은 무한 루프입니다.
      </div>
      <div id="controls">
        <button id="toggleMotionButton" class="controlButton">흐름: ON</button>
        <button id="toggleDirectionButton" class="controlButton">방향: ↑</button>
        <button id="clearButton" class="controlButton">전체 삭제</button>
      </div>
    </div>

    <div id="noteLayer"></div>

    <div id="editorOverlay" role="dialog" aria-modal="true">
      <div id="editorPanel">
        <div id="editorHeader">
          <div id="editorTitle">메모 편집</div>
          <div style="opacity:0.7;font-size:12px;">Esc로 닫기</div>
        </div>
        <textarea id="editorTextarea" placeholder="메모 내용을 입력하세요"></textarea>
        <div id="editorActions">
          <button id="deleteNoteButton" class="editorButton danger">삭제</button>
          <button id="cancelEditButton" class="editorButton">취소</button>
          <button id="saveEditButton" class="editorButton">저장</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const viewportElement = document.getElementById("viewport");
    const noteLayerElement = document.getElementById("noteLayer");

    const toggleMotionButton = document.getElementById("toggleMotionButton");
    const toggleDirectionButton = document.getElementById("toggleDirectionButton");
    const clearButton = document.getElementById("clearButton");

    const editorOverlay = document.getElementById("editorOverlay");
    const editorTextarea = document.getElementById("editorTextarea");
    const cancelEditButton = document.getElementById("cancelEditButton");
    const saveEditButton = document.getElementById("saveEditButton");
    const deleteNoteButton = document.getElementById("deleteNoteButton");

    const localStorageKey = "infiniteMemoFlow.notes.v1";

    const worldHeightPixels = 3200;
    const worldPaddingPixels = 40;

    let isMotionEnabled = true;
    let scrollDirection = -1;
    let scrollSpeedPixelsPerSecond = 14;

    let scrollOffsetY = 0;
    let lastAnimationTimestamp = performance.now();
    let hoverPauseCount = 0;

    /** @type {Array<{
     *   id: string,
     *   worldX: number,
     *   worldY: number,
     *   rotationDegrees: number,
     *   backgroundColorCss: string,
     *   text: string,
     *   createdAtIso: string
     * }>} */
    let notes = [];

    let currentlyEditingNoteId = null;
    let longPressTimerId = null;

    function generateId() {
      return "note_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }

    function clampNumber(value, minimum, maximum) {
      return Math.min(Math.max(value, minimum), maximum);
    }

    function wrapNumber(value, modulo) {
      const wrapped = value % modulo;
      return wrapped < 0 ? wrapped + modulo : wrapped;
    }

    function formatTimestamp(isoString) {
      const date = new Date(isoString);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      return `${year}.${month}.${day} ${hours}:${minutes}`;
    }

    function smoothFieldNoise(normalizedX, normalizedY) {
      const tau = Math.PI * 2;
      const wave1 = Math.sin(tau * (normalizedX * 2.35 + normalizedY * 1.55));
      const wave2 = Math.sin(tau * (normalizedX * 1.10 - normalizedY * 2.10));
      const wave3 = Math.sin(tau * (normalizedX * 0.55 + normalizedY * 0.85));
      return (0.55 * wave1 + 0.30 * wave2 + 0.15 * wave3);
    }

    function oklchToSrgbCss(lightness, chroma, hueDegrees) {
      const hueRadians = (hueDegrees * Math.PI) / 180;
      const a = chroma * Math.cos(hueRadians);
      const b = chroma * Math.sin(hueRadians);

      const l_ = lightness + 0.3963377774 * a + 0.2158037573 * b;
      const m_ = lightness - 0.1055613458 * a - 0.0638541728 * b;
      const s_ = lightness - 0.0894841775 * a - 1.2914855480 * b;

      const l = l_ * l_ * l_;
      const m = m_ * m_ * m_;
      const s = s_ * s_ * s_;

      const linearRed   = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
      const linearGreen = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
      const linearBlue  = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

      function linearToSrgb(channel) {
        const clamped = clampNumber(channel, 0, 1);
        if (clamped <= 0.0031308) return 12.92 * clamped;
        return 1.055 * Math.pow(clamped, 1 / 2.4) - 0.055;
      }

      const red = Math.round(255 * linearToSrgb(linearRed));
      const green = Math.round(255 * linearToSrgb(linearGreen));
      const blue = Math.round(255 * linearToSrgb(linearBlue));

      return `rgb(${red} ${green} ${blue})`;
    }

    function colorFromViewportPosition(viewportX, viewportY) {
      const viewportWidth = viewportElement.clientWidth;

      const normalizedX = clampNumber(viewportX / Math.max(viewportWidth, 1), 0, 1);
      const worldY = wrapNumber(viewportY + scrollOffsetY, worldHeightPixels);
      const normalizedWorldY = worldY / Math.max(worldHeightPixels, 1);
      const normalizedY = clampNumber(viewportY / Math.max(viewportElement.clientHeight, 1), 0, 1);

      const noise = smoothFieldNoise(normalizedX, normalizedWorldY);
      const loopWave = Math.sin(Math.PI * 2 * normalizedWorldY);

      const baseHueDegrees = 210 + 150 * normalizedX + 35 * loopWave;
      const hueDegrees = wrapNumber(baseHueDegrees + 10 * noise, 360);

      const lightness = clampNumber(0.76 + 0.12 * loopWave + 0.02 * noise, 0.58, 0.90);

      const distanceFromCenterY = Math.abs(normalizedY - 0.5) * 2;
      const chroma = clampNumber(0.14 - 0.05 * distanceFromCenterY + 0.01 * noise, 0.06, 0.18);

      return oklchToSrgbCss(lightness, chroma, hueDegrees);
    }

    function saveNotesToLocalStorage() {
      try {
        localStorage.setItem(localStorageKey, JSON.stringify(notes));
      } catch (error) {
      }
    }

    function loadNotesFromLocalStorage() {
      try {
        const raw = localStorage.getItem(localStorageKey);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return;
        notes = parsed;
      } catch (error) {
      }
    }

    function clearAllNotes() {
      notes = [];
      saveNotesToLocalStorage();
      renderAllNotes();
    }

    function deleteNoteById(noteId) {
      notes = notes.filter((note) => note.id !== noteId);
      saveNotesToLocalStorage();
      renderAllNotes();
    }

    function createNoteElement(note) {
      const noteElement = document.createElement("div");
      noteElement.className = "note";
      noteElement.dataset.noteId = note.id;
      noteElement.style.background = note.backgroundColorCss;
      noteElement.style.setProperty("--note-rotate", `${note.rotationDegrees}deg`);

      const noteBodyElement = document.createElement("div");
      noteBodyElement.className = "noteBody";
      noteBodyElement.textContent = note.text || "새 메모";

      const noteTimestampElement = document.createElement("div");
      noteTimestampElement.className = "noteTimestamp";
      noteTimestampElement.textContent = formatTimestamp(note.createdAtIso);

      noteElement.appendChild(noteBodyElement);
      noteElement.appendChild(noteTimestampElement);

      noteElement.addEventListener("dblclick", (event) => {
        event.stopPropagation();
        openEditor(note.id);
      });

      noteElement.addEventListener("pointerdown", (event) => {
        if (event.pointerType === "mouse") return;
        longPressTimerId = window.setTimeout(() => {
          openEditor(note.id);
        }, 520);
      });
      noteElement.addEventListener("pointerup", () => {
        if (longPressTimerId) window.clearTimeout(longPressTimerId);
        longPressTimerId = null;
      });
      noteElement.addEventListener("pointercancel", () => {
        if (longPressTimerId) window.clearTimeout(longPressTimerId);
        longPressTimerId = null;
      });

      noteElement.addEventListener("pointerenter", (event) => {
        if (event.pointerType !== "mouse") return;
        noteElement.classList.add("is-hovered");
        hoverPauseCount += 1;
      });

      noteElement.addEventListener("pointerleave", (event) => {
        if (event.pointerType !== "mouse") return;
        noteElement.classList.remove("is-hovered");
        hoverPauseCount = Math.max(0, hoverPauseCount - 1);
      });

      return noteElement;
    }

    function renderAllNotes() {
      noteLayerElement.innerHTML = "";
      for (const note of notes) {
        const noteElement = createNoteElement(note);
        noteLayerElement.appendChild(noteElement);
      }
    }

    function findNoteById(noteId) {
      return notes.find((note) => note.id === noteId) || null;
    }

    function openEditor(noteId) {
      const note = findNoteById(noteId);
      if (!note) return;

      currentlyEditingNoteId = noteId;
      editorTextarea.value = note.text || "";
      editorOverlay.style.display = "flex";
      editorTextarea.focus();
      editorTextarea.setSelectionRange(editorTextarea.value.length, editorTextarea.value.length);
    }

    function closeEditor() {
      currentlyEditingNoteId = null;
      editorOverlay.style.display = "none";
      editorTextarea.value = "";
    }

    function saveEditorChanges() {
      if (!currentlyEditingNoteId) return;
      const note = findNoteById(currentlyEditingNoteId);
      if (!note) return;

      note.text = editorTextarea.value.trim() ? editorTextarea.value : "새 메모";
      saveNotesToLocalStorage();
      renderAllNotes();
      closeEditor();
    }

    function deleteCurrentlyEditingNote() {
      if (!currentlyEditingNoteId) return;
      deleteNoteById(currentlyEditingNoteId);
      closeEditor();
    }

    function addNoteAtViewportPosition(viewportX, viewportY) {
      const viewportWidth = viewportElement.clientWidth;

      const backgroundColorCss = colorFromViewportPosition(viewportX, viewportY);

      const worldX = clampNumber(viewportX, worldPaddingPixels, Math.max(worldPaddingPixels, viewportWidth - worldPaddingPixels - 220));
      const worldY = wrapNumber(viewportY + scrollOffsetY, worldHeightPixels);

      const rotationDegrees = (Math.random() * 6) - 3;

      const newNote = {
        id: generateId(),
        worldX,
        worldY,
        rotationDegrees,
        backgroundColorCss,
        text: "새 메모",
        createdAtIso: new Date().toISOString()
      };

      notes.push(newNote);
      saveNotesToLocalStorage();

      const noteElement = createNoteElement(newNote);
      noteLayerElement.appendChild(noteElement);

      openEditor(newNote.id);
    }

    function isClickOnExistingNote(targetElement) {
      return Boolean(targetElement.closest && targetElement.closest(".note"));
    }

    function updateNoteElementPositions() {
      const viewportHeight = viewportElement.clientHeight;

      for (const noteElement of noteLayerElement.children) {
        const noteId = noteElement.dataset.noteId;
        const note = findNoteById(noteId);
        if (!note) continue;

        let displayY = note.worldY - scrollOffsetY;

        const approximateNoteHeight = 170;

        while (displayY < -approximateNoteHeight) displayY += worldHeightPixels;
        while (displayY > viewportHeight + approximateNoteHeight) displayY -= worldHeightPixels;

        noteElement.style.left = `${note.worldX}px`;
        noteElement.style.top = `${displayY}px`;
      }
    }

    function animationLoop(timestamp) {
      const deltaMilliseconds = timestamp - lastAnimationTimestamp;
      lastAnimationTimestamp = timestamp;

      if (isMotionEnabled && hoverPauseCount === 0) {
        const deltaSeconds = deltaMilliseconds / 1000;
        scrollOffsetY = wrapNumber(
          scrollOffsetY + (scrollDirection * scrollSpeedPixelsPerSecond * deltaSeconds),
          worldHeightPixels
        );
      }

      updateNoteElementPositions();
      requestAnimationFrame(animationLoop);
    }

    viewportElement.addEventListener("pointerdown", (event) => {
      if (editorOverlay.style.display === "flex") return;
      if (event.target.closest("#controls")) return;
      if (isClickOnExistingNote(event.target)) return;

      const rect = viewportElement.getBoundingClientRect();
      const viewportX = event.clientX - rect.left;
      const viewportY = event.clientY - rect.top;

      addNoteAtViewportPosition(viewportX, viewportY);
    });

    toggleMotionButton.addEventListener("click", () => {
      isMotionEnabled = !isMotionEnabled;
      toggleMotionButton.textContent = `흐름: ${isMotionEnabled ? "ON" : "OFF"}`;
    });

    toggleDirectionButton.addEventListener("click", () => {
      scrollDirection *= -1;
      toggleDirectionButton.textContent = `방향: ${scrollDirection < 0 ? "↑" : "↓"}`;
    });

    clearButton.addEventListener("click", () => {
      clearAllNotes();
    });

    cancelEditButton.addEventListener("click", closeEditor);
    saveEditButton.addEventListener("click", saveEditorChanges);
    deleteNoteButton.addEventListener("click", deleteCurrentlyEditingNote);

    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape" && editorOverlay.style.display === "flex") {
        closeEditor();
      }
    });

    loadNotesFromLocalStorage();
    renderAllNotes();
    updateNoteElementPositions();
    requestAnimationFrame(animationLoop);

    window.addEventListener("resize", () => {
      const viewportWidth = viewportElement.clientWidth;
      for (const note of notes) {
        note.worldX = clampNumber(note.worldX, worldPaddingPixels, Math.max(worldPaddingPixels, viewportWidth - worldPaddingPixels - 220));
      }
      saveNotesToLocalStorage();
      updateNoteElementPositions();
    });
  </script>
</body>
</html>
